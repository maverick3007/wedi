var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var nodePath = require('path');
var fs = require('fs');
var glob = require('glob');

var pugLex = require('pug-lexer');
var pugParser = require('pug-parser');
var pugWalk = require('pug-walk');
var pugDependency = require('pug-dependency');

var pkginfo = {};
if (fs.existsSync('./package.json')) {
  pkginfo = JSON.parse(fs.readFileSync('./package.json', 'utf8'));
}

var resolvePath = function resolvePath(path, file, basedir, extension, purpose) {

  if (path[0] !== '/' && !file || path[0] !== '\\' && !file) {
    throw new Error(`the "filename" option is required to use "${purpose}" with "relative" paths`);
  }

  if (path[0] === '/' && !basedir || path[0] !== '\\' && !basedir) {
    throw new Error(`the "basedir" option is required to use "${purpose}" with "absolute" paths`);
  }

  path = nodePath.join(path[0] === '/' || path[0] === '\\' ? basedir : nodePath.dirname(file), path);
  if (nodePath.basename(path).indexOf(extension) === -1) {
    path += extension;
  }

  return path;
};

var Parser = function () {
  function Parser(filename, directory, options) {
    _classCallCheck(this, Parser);

    this.filename = filename;
    this.directory = directory;
    this.options = options;

    this.extension = '.pug';

    this.skipInheritances = this.options.skip ? this.options.skip : pkginfo.skipInheritances;

    this.cache = {};
    this.files = {};
    this.filename = nodePath.relative(this.options.basedir, this.filename);
    this.addFile(this.filename);

    var files = glob.sync(`${this.directory}/**/*${this.extension}`, { dot: true });
    this.tree = this.getInheritance(this.filename, files);

    files = this.files;

    this.files = [];
    for (filename in files) {
      this.files.push(filename);
    }
    this.dependencies = this.getDependencies(nodePath.join(this.options.basedir, this.filename));

    return this;
  }

  _createClass(Parser, [{
    key: 'getInheritance',
    value: function getInheritance(filename, files) {
      this.addFile(filename);
      var branch = {};
      if (branch[filename] == null) {
        branch[filename] = {};
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = Array.from(files)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var file = _step.value;

          if (typeof this.skipInheritances === 'object') {
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = Array.from(this.skipInheritances)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var skip = _step2.value;

                if (file.indexOf(skip) === -1) {
                  this.createInheritanceObject(file, files, filename, branch);
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          } else if (typeof this.skipInheritances === 'string') {
            if (file.indexOf(this.skipInheritances) === -1) {
              this.createInheritanceObject(file, files, filename, branch);
            }
          } else {
            console.warn('Skip inheritances is not set. This may throw an error, if basedir is set to "." and pug-inheritance is resolving files also in package folders.');
            this.createInheritanceObject(file, files, filename, branch);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return branch;
    }
  }, {
    key: 'createInheritanceObject',
    value: function createInheritanceObject(file, files, filename, branch) {
      var _this = this;

      var string = void 0;
      file = nodePath.normalize(file);
      var relativeFile = nodePath.relative(this.options.basedir, file);
      file = nodePath.join(this.options.basedir, relativeFile);
      if (this.cache[file] == null) {
        this.cache[file] = {};
      }

      if (this.cache[file].string != null) {
        string = this.cache[file].string;
      } else {
        string = this.cache[file].string = fs.readFileSync(file, 'utf8');
      }

      try {
        return pugWalk(pugParser(pugLex(string, { filename: file })), function (node) {
          var type = node.type;

          switch (type) {
            case 'Extends':
            case 'RawInclude':
            case 'Include':
              var path = resolvePath(node.file.path, file, _this.options.basedir, _this.extension, type);

              if (path === nodePath.join(_this.options.basedir, filename)) {
                var inheritance = void 0,
                    relationship = void 0;
                if (type === 'Extends') {
                  relationship = 'extendedBy';
                } else if (type === 'RawInclude' || type === 'Include') {
                  relationship = 'includedBy';
                }

                var newFile = {};

                if (_this.cache[file].inheritance != null) {
                  inheritance = _this.cache[file].inheritance;
                } else {
                  inheritance = _this.cache[file].inheritance = _this.getInheritance(relativeFile, files);
                }

                newFile = inheritance;

                if (branch[filename][relationship] == null) {
                  branch[filename][relationship] = [];
                }
                branch[filename][relationship].push(newFile);
              }
              break;
          }
          return branch;
        });
      } catch (e) {
        throw e;
      }
    }
  }, {
    key: 'addFile',
    value: function addFile(filename) {
      if (this.files[filename] == null) {
        return this.files[filename] = null;
      }
    }
  }, {
    key: 'getDependencies',
    value: function getDependencies(filePath) {
      var _this2 = this;

      var getDependencies = pugDependency(`${this.directory}/**/*${this.extension}`);
      var dependencies = [];

      getDependencies.find_dependencies(filePath).forEach(function (dependency) {
        var pathToDependencie = nodePath.relative(_this2.options.basedir, dependency);
        if (dependencies.indexOf(pathToDependencie) === -1) {
          dependencies.push(pathToDependencie);
        }
      });

      return dependencies;
    }
  }]);

  return Parser;
}();

module.exports = Parser;